"""Define the database API."""

import getpass
from os import access, R_OK, W_OK
import pathlib
import smtplib
import sqlite3
from types import TracebackType

import feedparser as fp
import keyring

from podd.settings import Config
from podd.utilities import logger


class Database:
    """
    Defines database operations - Adding, removing, getting podcasts and episodes
    from the database, etc
    """

    def __init__(self, db_file: str = Config.database):
        self._db_file = db_file
        self._conn = sqlite3.connect(self._db_file)
        self._conn.execute('PRAGMA foreign_keys=ON')
        self.cursor = self._conn.cursor()
        self._logger = logger(f'{self.__class__.__name__}')

    def __enter__(self):
        """Context method."""
        return self

    def __exit__(self,
                 exc_type,
                 exc_val,
                 exc_tb: TracebackType):
        """Context method.

        If there are exceptions, rolls back and calls logger
        :param exc_type: exception type
        :param exc_val:  exception value
        :param exc_tb: exception traceback
        :return: None
        """
        if exc_type is not None:
            self._conn.rollback()
            self._logger.error(exc_type, exc_val, exc_tb)

        else:
            self._conn.commit()
        self._conn.close()

    def __repr__(self):
        """`repr` method."""
        return f'{self.__class__.__name__}({self._db_file})'

    def add_podcast(self, name: str, url: str, directory: str) -> None:
        """Save podcast to database.

        :param name: podcast name
        :param url: rss feed url
        :param directory: directory to store this podcast's downloaded episodes
        :return: None
        """
        self._logger.info(f'Adding {name} {url} at {directory}')
        self.cursor.executemany('INSERT INTO podcasts (name, url, directory) VALUES (?,?,?)',
                                ((name, url, directory),))
        self._conn.commit()

    def remove_podcast(self, url: str) -> None:
        """Delete podcast and associated episodes from database.

        Deletes all episodes associated with rss feed URL, as well as podcast entry
        :param url: rss feed url
        :return: None
        """
        self.cursor.execute('DELETE FROM episodes WHERE podcast_id IN'
                            ' (SELECT id FROM podcasts p WHERE p.url = ?)', (url,))
        self.cursor.execute('DELETE FROM  podcasts WHERE url = ?',
                            (url,))
        self._conn.commit()

    def get_podcasts(self) -> list:
        """Return list of podcasts.

        :return: list of tuples of podcast name, url and download directory
        """
        self.cursor.execute('SELECT name, url, directory FROM main.podcasts')
        return self.cursor.fetchall()

    def add_episode(self,
                    podcast_url: str,
                    feed_id: str, ) -> None:
        """Save episode to database.

        :param podcast_url: RSS feed URL
        :param feed_id: id generated by rss feed for each episode
        :return: None
        """
        self.cursor.execute('INSERT INTO episodes (feed_id, podcast_id) '
                            'SELECT ?, id FROM main.podcasts WHERE url = ?',
                            (feed_id, podcast_url))
        self._conn.commit()

    def get_episodes(self, url: str) -> set:
        """Return episodes from a single podcast.

        :param url: rss feed url
        :return: dict of episode ids associated with url
        """
        self.cursor.execute('SELECT feed_id FROM episodes '
                            'JOIN podcasts p ON episodes.podcast_id = p.id AND p.url = ?',
                            (url,))
        return {item[0] for item in self.cursor.fetchall()}

    def get_options(self) -> tuple:
        """Return options.

        :return: tuple of currently set options
        """
        self.cursor.execute('SELECT '
                            'download_directory, '
                            'notification_status, '
                            'recipient_address FROM settings')
        return self.cursor.fetchone()

    def get_credentials(self) -> tuple:
        """Return credentials.

        :return: tuple of sender_address, and recipient_address
        """
        self.cursor.execute('SELECT sender_address, '
                            'recipient_address from settings where id = 1')
        sender, recipient = self.cursor.fetchone()
        password = keyring.get_password('podd', sender)
        return sender, password, recipient

    def change_option(self, option: str, value: str or int) -> None:
        """Save option changes to database.

        I know, I know, using a database query with an fstring is problematic,
        Ã  la bobby tables, but the user doesn't interact directly with the
        database with this or any other queries that use fstrings in queries.
        All values input by the user are parameterized, which mitigates the threat.
        Given what this application is and does, I'm not sure why any user would
        try to sql injection on a local db of which they have sole access.
        :param option: string, option to change
        :param value: string, option's new value
        :return: None
        """
        self.cursor.execute(f'UPDATE settings SET {option} = ? WHERE id = 1', (value,))
        self._conn.commit()
        if option == 'sender_password':
            value = 'REDACTED'
        self._logger.info(f'Changed {option} to {value}')


class Feed(Database):
    """Combine database and rss feed functionality.

    Contains methods for managing rss feeds, including adding and removing podcasts
    to database, viewing current subscription feeds, etc
    """

    def add(self, url, newest_only: bool=False) -> None:
        """Add podcast to database.

        Parses and validates rss feed urls, adds to database, creates
        download directory for each new feed added.
        :param newest_only: bool if set, only download newest episode, which is
          accomplished by adding all episodes, except for the newest, to the episode
          table in the database.
        :param url: rss feed url
        :return: None
        """
        try:
            dl_dir, *_ = self.get_options()
            feed = fp.parse(url)
            self._logger.info(f'Parsing {url}')
            episodes = feed.entries
            if not episodes:
                msg = f'No episodes at {url}'
                self._logger.warning(msg)
            else:
                podcast_name = feed.feed.title
                # podcast_dir = path.join(dl_dir, podcast_name)
                podcast_dir = pathlib.Path(dl_dir).joinpath(podcast_name)
                podcast_dir.mkdir(parents=True, exist_ok=True)
                self.add_podcast(name=podcast_name, url=feed.href, directory=str(podcast_dir))
                # url=feed.href covers cases when rss feeds redirect to a diff URL.
                # That was a fun one to debug.
                if newest_only:
                    self._new_podcast_only(feed=feed)
                msg = f'{podcast_name} added'
                self._logger.info(msg)
        except sqlite3.IntegrityError:
            msg = f'{podcast_name} already in database.'
            self._logger.warning(msg)
        print(msg)

    def remove(self) -> None:
        """Define podcast deletion menu.

        Creates a simple podcast deletion menu.  Is interactive in order to be
        slightly more user-friendly.
        :return: None
        """
        podcasts = {i[0]: i[1] for i in enumerate(self.get_podcasts())}
        if not podcasts:
            print('You have no subscriptions!')
            return
        for num, podcast in podcasts.items():
            print(f'{num}: {podcast[0]}')
        try:
            choice = int(input('Podcast number to remove: '))
            if choice not in podcasts:
                print('Invalid option')
                return
            self.remove_podcast(podcasts[choice][1])
            msg = f'Removed {podcasts[choice][0]}'
            print(msg)
            self._logger.info(msg)
        except ValueError:
            print('Invalid option, enter a number')
        except KeyboardInterrupt:
            print('\nCanceled')

    def _new_podcast_only(self, feed: fp.FeedParserDict) -> None:
        """Add all episodes (Except for latest) to database.

        Used when adding a new podcast to the database.
        :param feed: FeedParserDict of a single feed
        :return: None
        """
        episodes = feed.entries
        first = episodes[0].published_parsed
        last = episodes[-1].published_parsed
        if first < last:  # Last is the latest episode, i.e., feed is reversed
            episodes = episodes[:-1]
        else:
            episodes = episodes[1:]
        for epi in episodes:
            self.add_episode(podcast_url=feed.href, feed_id=epi.id)

    def print_subscriptions(self) -> None:
        """
        Prints current subscriptions
        :return: None
        """
        subs = self.get_podcasts()
        if subs:
            print('----------Current subscriptions----------')
            for sub in subs:
                print(sub[0])
            print('-----------------------------------------')
        else:
            print('No active subscriptions.')


class Options(Database):
    """
    Contains methods to manage and view options stored in the database.
    """

    def toggle_notifications(self, value) -> None:
        """
        Turns email notifications on or off, depending upon supplied value
        :param value:
        :return:
        """
        valid = {'on': True, 'off': False}
        if value not in valid:
            print('Invalid option')
            return
        sender, *_ = self.get_credentials()
        if sender == '' and value == 'on':
            print('You need to enter a valid email address.  Run `python3 podd.py email` first.')
            return
        self.change_option('notification_status', valid[value])
        msg = f'Notifications turned {value}.'
        print(msg)
        self._logger.info(msg)

    def email_notification_setup(self, initial_setup: bool = False) -> None:
        """Get and store email credentials.

       Interacts with user, gets sender email address and password, as well as recipient address
       :param initial_setup: bool if True, prints additional info
       :return: namedtuple of sender address and password and recipient address
       """

        def credential_validation() -> bool:
            """
            creates a simple smtp server and attempts to log in to server using the
            provided credentials
            :return: bool, True if login attempt was successful, False otherwise
            """
            server = smtplib.SMTP(host=Config.host, port=Config.port)
            server.starttls()
            try:
                status_code = server.login(user=sender_address, password=password)[0]
                server.quit()
                if status_code == 235:
                    return True
            except smtplib.SMTPAuthenticationError:
                pass
            return False

        if initial_setup:
            print('Looks like this is your first time running the program.')
            choice = input('Would you like to enable email notifications? (y/n) ').lower()
            if choice != 'y':
                msg = 'Email notifications disabled.'
                print(msg)
                self._logger.info(msg)
                return
        print('\nNote: if you are using a Gmail account for this purpose, you need \n'
              'to enable app-specific passwords and enter one you\'ve generated, \n'
              'rather than your normal password.  This is somewhat risky, so it is\n'
              'advised that you do NOT use your main gmail account for this purpose. \n'
              'See https://support.google.com/accounts/answer/185833?hl=en for more info.\n'
              'The default values in config.py use the ones provided by gmail, \n'
              'if you choose to use a different email provider, replace them with the\n'
              'correct values.\n')
        print('First, enter in the address you want to use to send notifications')
        try:
            sender_address = input('Email address: ')
            password = getpass.getpass('Password: ')
            print('Validating password...')
            if not credential_validation():
                msg = 'Login attempt failed!  Bad username or password!'
                self._logger.warning(msg)
                print(msg)
                return
            msg = 'Email authentication successful.'
            self._logger.info(msg)
            print(msg)
            print('\nNow enter the recipient email address.')
            recipient_address = input('Email address: ')
            keyring.set_password('podd', sender_address, password)
            self.change_option('sender_address', sender_address)
            self.change_option('recipient_address', recipient_address)
            self.change_option('notification_status', True)
            msg = 'Email notification enabled!'
            print(msg)
            self._logger.info(msg)
        except KeyboardInterrupt:
            print('\nCanceling')
            quit()

    def print_options(self) -> tuple:
        """
        Prints currently selected options
        :return: None
        """
        email_notification_status = {0: 'Off', 1: 'On'}
        download_directory, notification_status, recipient_address = self.get_options()
        print('-- Options --')
        print(f'Download Directory: {download_directory}')
        print(f'Email notifications: {email_notification_status[notification_status]}')
        if notification_status:
            print(f'Email notifications sent to: {recipient_address}')
        print(f'Database file: {self._db_file}')
        print('-------------')
        return download_directory, notification_status, recipient_address

    def set_directory_option(self, directory) -> bool:
        """
        Sets the base download directory, where each individual podcast
        download directory will be created
        :param directory: string, abs path to base download directory
        :return: None
        """
        if access(directory, W_OK) and access(directory, R_OK):
            self.change_option('download_directory', directory)
            msg = f'Changed download directory to {directory}'
            print(msg)
            self._logger.info(msg)
            return True
        msg = f'Invalid directory: {directory}'
        print(msg)
        self._logger.warning(msg)
        return False


def create_database(database: str = Config.database) -> bool:
    """Create database.

    Looks in the directory of the given filename, if the file is absent,
    it creates the database with default values.
    :param database: string, abs path of database file
    :return: None
    """
    exists = False
    for file in pathlib.Path(database).parent.iterdir():
        if database == str(file):
            exists = True
            break
    if not exists:
        sender, recipient, notifications = '', '', False
        with Database(database) as _db:
            cur = _db.cursor
            cur.execute('CREATE TABLE IF NOT EXISTS podcasts '
                        '(id INTEGER PRIMARY KEY, '
                        'name TEXT, '
                        'url TEXT UNIQUE, '
                        'directory TEXT)')
            cur.execute('CREATE TABLE IF NOT EXISTS episodes '
                        '(id INTEGER PRIMARY KEY, '
                        'feed_id TEXT, '
                        'podcast_id INTEGER NOT NULL,'
                        'FOREIGN KEY (podcast_id) REFERENCES podcasts(id))')
            cur.execute('CREATE TABLE IF NOT EXISTS settings '
                        '(id INTEGER PRIMARY KEY, '
                        'download_directory TEXT,'
                        'notification_status BOOLEAN,'
                        'sender_address TEXT,'
                        'recipient_address TEXT)')
            cur.execute('INSERT INTO settings ('
                        ' download_directory,'
                        ' notification_status,'
                        ' sender_address,'
                        ' recipient_address) VALUES (?,?,?,?)',
                        (str(pathlib.Path.home().joinpath('Podcasts')),
                         notifications,
                         sender,
                         recipient))
        pathlib.Path(__file__).parent.joinpath('Logs').mkdir(exist_ok=True)
        return True
    return False
